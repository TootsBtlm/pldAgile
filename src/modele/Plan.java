// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package modele;

import java.sql.Time;
import java.util.ArrayList;
import java.util.HashMap;
import javafx.util.Pair;


/************************************************************/
/**
 * 
 */
public class Plan {
	/**
	 * 
	 */
	private ArrayList<Long> intersectionId;	
	/**
	 * 
	 */
	private HashMap<Long,Integer> intersectionIdRetourne = new HashMap<Long, Integer>();
	/**
	 * 
	 */
	private ArrayList<Intersection> intersection;
	/**
	 * 
	 */
	private ArrayList<Segment> segment;
	
	private HashMap<Intersection, ArrayList<Segment>> listeAdjacence = new HashMap<Intersection, ArrayList<Segment>>();
	
	private HashMap<Intersection, ArrayList<Segment>> listeAdjacenceInverse = new HashMap<Intersection, ArrayList<Segment>>();
	 
	//public HashMap<Intersection, Integer> indexIdInteger = new HashMap<Intersection, Integer>();
	
	
	
	public HashMap<Intersection, ArrayList<Segment>> getListeAdjacence() {
		return listeAdjacence;
	}
	public void setListeAdjacence(HashMap<Intersection, ArrayList<Segment>> listeAdjacence) {
		this.listeAdjacence = listeAdjacence;
	}
	/* Method */
	
	/**
	 * Cette fonction modifie les intersections contenues dans le plan pour leur donner les idvisibles et pour leur donner un type 
	 * 
	 * pour rappel un idVisible est donné par couple d'intersections composant une requête 
	 * 
	 * le type est donné par ;
	 * 1 -> sommet quelconque
	 * 2-> dépot
	 * 3-> point de récupération
	 * 4 -> point de récupération 
	 * @param requetes
	 */
	public void modifierIntersectionsPertinentes(EnsembleRequete requetes) {
		ArrayList<Requete> listeRequetes = requetes.getListeRequete();
		for(int i = 0 ; i < requetes.getListeRequete().size() ; i++) {
			Intersection pointRecuperation  = listeRequetes.get(i).getPointDeRecuperation();
			Intersection pointLivraison  = listeRequetes.get(i).getPointDeRecuperation();
			
			Integer positionPointRecuperation = this.intersectionIdRetourne.get(pointRecuperation.getId());
			Integer positionPointLivraison = this.intersectionIdRetourne.get(pointLivraison.getId());
			
			this.intersection.set(positionPointRecuperation, pointRecuperation);
			this.intersection.set(positionPointLivraison, pointLivraison);
			
		}
	
	Intersection pointDeDepart = requetes.getLieuDepart().getPointDeDepart();
	
	Integer positionPointDeDepart =this.intersectionIdRetourne.get(pointDeDepart.getId());
	
	this.intersection.set(positionPointDeDepart, pointDeDepart);
	
	}
	/**
	 *  Cette fonction prend en paramètre une requête qu'elle traite, c'est à dire qu'elle calcule l'ordre dans lequel les intersections seront parcourues, par quel itinéraire, et a quel moment. 
	 *  Elle utilise le TSP et l'algorithme A* pour établire la livraison optimale. 
	 * @param requetes
	 * @return Livraison
	 */
	public Livraison getMatriceCout(EnsembleRequete requetes) {
		
		this.modifierIntersectionsPertinentes(requetes);
        
		ArrayList<Intersection> listeIntersection = new ArrayList<Intersection>();
        ArrayList<Pair<Integer,Integer>> listePaires = new ArrayList<Pair<Integer,Integer>>();
        listeIntersection.add(requetes.getLieuDepart().getPointDeDepart());
        for(int i=0; i<requetes.getListeRequete().size();i++) {
            listeIntersection.add(requetes.getListeRequete().get(i).getPointDeRecuperation());
            listeIntersection.add(requetes.getListeRequete().get(i).getPointDeLivraison());
            listePaires.add(new Pair<Integer,Integer>(listeIntersection.indexOf(requetes.getListeRequete().get(i).getPointDeRecuperation()),listeIntersection.indexOf(requetes.getListeRequete().get(i).getPointDeLivraison())));
        }
        double[][] matriceCout = new double[listeIntersection.size()][listeIntersection.size()];
        

        HashMap<Pair<Intersection, Intersection>, Itineraire> matriceItineraire = new HashMap<Pair<Intersection, Intersection>, Itineraire>();
        //System.out.println("calculs dans A*");
        for(int i=0;i<listeIntersection.size();i++) {
            for(int j=0;j<listeIntersection.size();j++) {
                if(i==j)
                    matriceCout[i][j] = -1;
                else {
                	//System.out.println(listeIntersection.get(i));
                	//System.out.println(listeIntersection.get(j));
                	Itineraire itineraire = aEtoile(listeIntersection.get(i),listeIntersection.get(j));
                	Pair<Intersection, Intersection> cle = new Pair<Intersection,Intersection>(listeIntersection.get(i),listeIntersection.get(j));
                	matriceItineraire.put(cle, itineraire);
                    matriceCout[i][j] = itineraire.getCout();
                }
            }
        }
        //System.out.println("résultat tsp : ");    
        TSP tsp = new TSP1();
        Integer[] resultat = tsp.searchSolution(30000, matriceCout, listePaires, 0);
        for(int i=0;i<resultat.length;i++){
        	
        	//System.out.println(i);
        	//System.out.println(resultat[i]);
        }
        
        //System.out.println("contenu matrice itineraire");
        
        for (HashMap.Entry<Pair<Intersection, Intersection>, Itineraire> entry : matriceItineraire.entrySet()) {
            //System.out.println("Key = " + entry.getKey());
            //System.out.println("Value debut = " + entry.getValue().getListeIntersections().get(0));
            //System.out.println("Value fin = " + entry.getValue().getListeIntersections().get(entry.getValue().getListeIntersections().size()-1));
        }

        
        Itineraire itineraireOpti = new Itineraire();
        
        for(int i=0;i<resultat.length;i++) {
        	itineraireOpti.addIntersection(listeIntersection.get(resultat[i]));	
        }
        
        // La liste des sommets à parcourir dans l'ordre 
        itineraireOpti.addIntersection(requetes.getLieuDepart().getPointDeDepart());
        
        
        ArrayList<Itineraire> itineraireComplet = new ArrayList<Itineraire>();
        
        for(int i=0;i<itineraireOpti.getListeIntersections().size()-1;i++) {
        	Pair<Intersection, Intersection> cle = new Pair<Intersection, Intersection>(itineraireOpti.getListeIntersections().get(i), itineraireOpti.getListeIntersections().get(i+1));
        	itineraireComplet.add(matriceItineraire.get(cle));
        }
        Livraison ret = new Livraison(itineraireComplet,requetes);
        ret.calculArrivees();
        return(ret);
    }

	/**
	 * Cette fonction retourne le nom d'une rue passant par l'intersection passée en commentaire
	 * @param intersections
	 * @return String
	 */
	public String getNomRue(Intersection intersections) {
		
		String nomRue = new String();
		for(int i = 0; i< this.getSegment().size() ; i++) {
			Segment segment = this.getSegment().get(i);
			if(segment.getOrigine().getId() == intersections.getId() || segment.getFin().getId() == intersections.getId()  ) {
				nomRue = segment.getNom();
			}
		}
		 
		
		return nomRue;
	}

	/**
	 * Cette fonction va permettre d'ajouter une requete au parcours du cycliste
	 * @return Livraison
	 */
	
	public Livraison ajouterRequete(Livraison ancienneLivraison, Intersection precedentRecuperation, Intersection precedentLivraison, Intersection pointRecuperation, Intersection pointLivraison,  Long dureeRecuperation, Long dureeLivraison) {
//		System.out.println("Nouvel itinéraire en cours de calcul");
//		System.out.println(ancienneLivraison.getListeItineraires().size());
		
		
		//test d'intégrité de la demande
		boolean integre = true;
		boolean recupere = false;
		
		for(int i = 1 ; i < ancienneLivraison.getListeItineraires().size()-1; i++) {
			if(ancienneLivraison.getListeItineraires().get(i).getListeIntersections().get(0).getId() == precedentRecuperation.getId()) {
				recupere = true;
			}
			if(!recupere && ancienneLivraison.getListeItineraires().get(i).getListeIntersections().get(0).getId() == precedentLivraison.getId()) {
				integre = false;
			}
			
		}
		
		
		if(integre) {
			EnsembleRequete requetes = ancienneLivraison.getRequetes();
			Requete nouvelleRequete = new Requete( pointRecuperation,  pointLivraison, dureeRecuperation, dureeLivraison );
			ArrayList<Requete> listeRequetes = requetes.getListeRequete();
			pointRecuperation.setIdVisible( Integer.toUnsignedLong((requetes.getListeRequete().size()+2) ));
			pointLivraison.setIdVisible( Integer.toUnsignedLong((requetes.getListeRequete().size()+2) ));
			
			listeRequetes.add(nouvelleRequete);
			requetes.setListeRequete(listeRequetes);
			
			this.modifierIntersectionsPertinentes(requetes);
			Livraison livraison = new Livraison();
			
			ArrayList<Itineraire> ancienneListeisteItineraires =  ancienneLivraison.getListeItineraires();
			ArrayList<Itineraire> nouvelleListeisteItineraires =  new ArrayList<Itineraire>();
			for(int i  = 0 ; i < ancienneListeisteItineraires.size() ; i++) {
				if(ancienneListeisteItineraires.get(i).getListeIntersections().get(0).getId() == precedentRecuperation.getId() && ancienneListeisteItineraires.get(i).getListeIntersections().get(0).getId() == precedentLivraison.getId()) {
					Intersection depart = ancienneListeisteItineraires.get(i).getListeIntersections().get(0);
					Intersection arrivee = ancienneListeisteItineraires.get(i).getListeIntersections().get(ancienneListeisteItineraires.get(i).getListeIntersections().size()-1);
					nouvelleListeisteItineraires.add(this.aEtoile(depart, pointRecuperation));
					nouvelleListeisteItineraires.add(this.aEtoile(pointRecuperation, pointLivraison));
					nouvelleListeisteItineraires.add(this.aEtoile(pointLivraison, arrivee));
				}
				else if(ancienneListeisteItineraires.get(i).getListeIntersections().get(0).getId() == precedentRecuperation.getId() ) {
					Intersection depart = ancienneListeisteItineraires.get(i).getListeIntersections().get(0);
					Intersection arrivee = ancienneListeisteItineraires.get(i).getListeIntersections().get(ancienneListeisteItineraires.get(i).getListeIntersections().size()-1);
					nouvelleListeisteItineraires.add(this.aEtoile(depart, pointRecuperation));
					nouvelleListeisteItineraires.add(this.aEtoile(pointRecuperation, arrivee));
//					System.out.println("Calcul recup");
				}
				else if(ancienneListeisteItineraires.get(i).getListeIntersections().get(0).getId() == precedentLivraison.getId()){
					Intersection depart = ancienneListeisteItineraires.get(i).getListeIntersections().get(0);
					Intersection arrivee = ancienneListeisteItineraires.get(i).getListeIntersections().get(ancienneListeisteItineraires.get(i).getListeIntersections().size()-1);
					nouvelleListeisteItineraires.add(this.aEtoile(depart, pointLivraison));
					nouvelleListeisteItineraires.add(this.aEtoile(pointLivraison, arrivee));
//					System.out.println("Calcul livraison");
				}
				else {
					nouvelleListeisteItineraires.add(ancienneListeisteItineraires.get(i));
//					System.out.println("Retranscription");
				}
			}
			Livraison nouvelleLivraison = new Livraison(nouvelleListeisteItineraires, requetes);
			nouvelleLivraison.calculArrivees();
			
//			System.out.println("Nouvel itinéraire calculé !");
//			System.out.println(nouvelleLivraison.getListeItineraires().size());
			System.out.println("Affichage  de la nouvelle livraison");
//			System.out.println(nouvelleLivraison.getListeItineraires());
			for(int i = 0 ; i < nouvelleLivraison.getListeItineraires().size(); i++) {
				System.out.println(nouvelleLivraison.getListeItineraires().get(i).getListeIntersections().get(0));
				System.out.println(nouvelleLivraison.getListeItineraires().get(i).getListeIntersections().get(nouvelleLivraison.getListeItineraires().get(i).getListeIntersections().size() -1));
				
			}
			return nouvelleLivraison;
		}else {
			return null;
		}
		

		
		
		
	}

	/**
	 * Cette fonction supprime un des sommets parcouru par le cycliste.
	 * @param ancienneListeItineraire
	 * @param sommetASupprimer
	 * @return
	 */
	public ArrayList<Itineraire> supprimerSommet(ArrayList<Itineraire> ancienneListeItineraire, Intersection sommetASupprimer){
		
		ArrayList<Itineraire> nouvelleListeItineraire = new ArrayList<Itineraire>();
		int i = 0;
		while(i < ancienneListeItineraire.size()) {
			
			Itineraire ancienItineraire = ancienneListeItineraire.get(i);
			int itineraireSize = ancienItineraire.getListeIntersections().size();
			if(ancienItineraire.getListeIntersections().get(itineraireSize-1).getId() == sommetASupprimer.getId()) {
				Itineraire nouvelItineraire = this.aEtoile(ancienItineraire.getListeIntersections().get(0),ancienneListeItineraire.get(i+1).getListeIntersections().get(ancienneListeItineraire.get(i+1).getListeIntersections().size()-1));
				nouvelleListeItineraire.add(nouvelItineraire);
				i++;
				i++;
			}
			else {
				nouvelleListeItineraire.add(ancienItineraire);
				i++;
			}
		}

		
		
		
	return 	nouvelleListeItineraire;
	}
	
	/**
	 * Cette fonction supprime une des requêtes traitées lors de la livraison
	 * @param ancienneLivraison
	 * @param sommetASupprimer
	 * @return
	 */
	public Livraison supprimerRequete(Livraison ancienneLivraison, Intersection sommetASupprimer) {
		
		Requete requeteASupprimer = new Requete();
		boolean requeteTrouvee = false;
		EnsembleRequete requetes = ancienneLivraison.getRequetes();
		ArrayList<Requete> listeRequetes = requetes.getListeRequete(); 
		for(int i = 0 ; i< listeRequetes.size(); i++) {
			if(sommetASupprimer.getId() == listeRequetes.get(i).getPointDeLivraison().getId() || sommetASupprimer.getId() == listeRequetes.get(i).getPointDeRecuperation().getId()) {
				requeteASupprimer = listeRequetes.get(i);
				requeteTrouvee = true;

				
			}
		}
		
		
		if(requeteTrouvee) {
			
			listeRequetes.remove(requeteASupprimer);
			requetes.setListeRequete(listeRequetes);
			Time debutRequete = ancienneLivraison.getHeureDepart();
			
			Intersection intersectionASupprimerDepart = requeteASupprimer.getPointDeRecuperation();
			Intersection intersectionASupprimerarrivee = requeteASupprimer.getPointDeLivraison();
			
			
			
			ArrayList<Itineraire> nouvelleListeItineraire = supprimerSommet(ancienneLivraison.getListeItineraires(),intersectionASupprimerarrivee) ;
			nouvelleListeItineraire = supprimerSommet(nouvelleListeItineraire,intersectionASupprimerDepart) ;

			

			
			
			Livraison nouvelleLivraison = new Livraison( nouvelleListeItineraire , requetes);
			nouvelleLivraison.calculArrivees();
			return nouvelleLivraison; 
			
			
		}
		else {
			return ancienneLivraison;
		}
		
	}
	/**
	 * Cette méthode donne le chemin optimal pour relier deux sommets grâce à l'algorithme A*
	 * @param depart
	 * @param arrivee
	 * @return
	 */
	public Itineraire aEtoile(Intersection depart, Intersection arrivee){
		
		// On gère préalablemet le cas limites ou le départ et l'arrivée sont confondus
	
		if(depart.getId() == arrivee.getId()) {
			ArrayList<Intersection> listeIntersections = new ArrayList<Intersection>();
			listeIntersections.add(arrivee);
			Double cout = 0.;
			return new Itineraire(listeIntersections, cout);
		}
		
		
	
		HashMap<Intersection,Double> tab = new HashMap<Intersection,Double>();
		HashMap<Intersection,Double> heuristique = new HashMap<Intersection,Double>();
		HashMap<Intersection, ArrayList<Intersection>> tabIntersection = new HashMap<Intersection, ArrayList<Intersection>>();
		HashMap<Intersection, ArrayList<String>> tabNomRues = new HashMap<Intersection, ArrayList<String>>();
		ArrayList<Intersection> visitee = new ArrayList<Intersection>();
		ArrayList<Intersection> nonVisitee = (ArrayList<Intersection>) this.intersection.clone();
		ArrayList<Intersection> voisinArrivee = new ArrayList<Intersection>();
		ArrayList<Segment> voisins = new ArrayList<Segment>();
		
		double latitudeArrivee = arrivee.getLatitude();
		double longitudeArrivee = arrivee.getLongitude();
		
		for(int i = 0 ; i < this.intersection.size(); i++) {
			Intersection intersectionCourante = this.intersection.get(i);
			double latitudeCourante = intersectionCourante.getLatitude();
			double longitudeCourante = intersectionCourante.getLongitude();
			Double distanceArrivee = 5000000*((latitudeCourante - latitudeArrivee)*(latitudeCourante - latitudeArrivee) + (longitudeCourante - longitudeArrivee)*(longitudeCourante - longitudeArrivee));
			//System.out.println(intersectionCourante.getLatitude());
			//System.out.println(intersectionCourante.getLongitude());
			//System.out.println(distanceArrivee);
			heuristique.put(intersectionCourante, distanceArrivee);
		}
		//System.out.println(heuristique.toString());
		//System.out.println("fini heuristique");
		
		for(int i=0;i<this.segment.size();i++) {	
			if(this.segment.get(i).getFin().getId() == arrivee.getId()) {
				voisinArrivee.add(segment.get(i).getOrigine());
			}
		}
		
		for(int i=0;i<this.intersection.size();i++) {
			ArrayList<Intersection> vide = new ArrayList<Intersection>();
			ArrayList<String> chaineVide = new ArrayList<String>(); 
			tab.put(this.intersection.get(i),100000.0);
			tabIntersection.put(this.intersection.get(i), vide);
			tabNomRues.put(this.intersection.get(i), chaineVide);
		}
		
		tab.put(depart, 0.0);
		
		
		
		boolean arriveDepartContigue = false;
		Segment departArrivee = new Segment();
		for(int i=0;i<this.listeAdjacence.get(depart).size();i++) {
			
			Segment s = this.listeAdjacence.get(depart).get(i);
			ArrayList<Intersection> vide = new ArrayList<Intersection>();
			ArrayList<String> chaineVide = new ArrayList<String>();
			
			tab.put(s.getFin(),s.getLongueur());
			vide.add(depart);
			//Vide.add(departArrivee.getFin());
			chaineVide.add(s.getNom());
			
			if(s.getFin().getId() == arrivee.getId()){
				arriveDepartContigue = true;
				departArrivee = s;
			}
			
			tabIntersection.put(s.getFin(), vide);
			tabNomRues.put(s.getFin(), chaineVide);
		}
		
		
	
		
		


		
		
		// Si les sommets de départ et d'arrivée sont reliés, on renvoie juste le segment qui les sépare
		
		if(arriveDepartContigue) {
			ArrayList<Intersection> listeInter = new ArrayList<Intersection>();
			listeInter.add(depart);
			listeInter.add(arrivee);
			
			ArrayList<String> listeNoms = new ArrayList<String>();
			listeNoms.add(departArrivee.getNom());
			return new Itineraire(listeInter, listeNoms, departArrivee.getLongueur());
		}
		
		for(int i=0;i<this.listeAdjacence.get(depart).size();i++) {
			
			Segment s = this.listeAdjacence.get(depart).get(i);
			
			ArrayList<Intersection> vide = tabIntersection.get(s.getFin());
			
			vide.add(s.getFin());

		}
		

		visitee.add(depart);
		nonVisitee.remove(depart);
		voisinArrivee.remove(depart);
		
		while(voisinArrivee.size() != 0 ) { // Tant que tous les voisins de l'intersection d'arrivï¿½e ne sont pas visitï¿½e
			//System.out.println("sizeVoisin : " + voisinArrivee.size());
			//System.out.println(voisinArrivee.size());
			Double mino = 100000000.;
			Integer index = 0;

			
			
			for(int i=0;i<this.intersection.size();i++) {
				Intersection intersectionAVisiter = this.intersection.get(i);
				
				if(tab.get(intersectionAVisiter) + heuristique.get(intersectionAVisiter) < mino && !visitee.contains(this.intersection.get(i))){
					mino = tab.get(this.intersection.get(i))+ heuristique.get(intersectionAVisiter);
					index = i;
				}
				
			}
			
			
			//System.out.println(mino);
			for(int i  = 0 ;  i < tab.size(); i++) {
				if(tab.get(this.intersection.get(i)) < 100000) {
					//System.out.println(this.intersection.get(i)+" : " + tab.get(this.intersection.get(i)));
				}
			}
			
			//System.out.println(tab);
			Intersection nouveauDepart = this.intersection.get(index);
			
			for(int i=0;i<this.listeAdjacence.get(nouveauDepart).size();i++) {

				Segment s = this.listeAdjacence.get(nouveauDepart).get(i);

					//System.out.println(s.toString());
					//System.out.println(tab.get(arrivee));
					if(tab.get(nouveauDepart) + s.getLongueur() < tab.get(s.getFin())) {
						
						tab.put(s.getFin(),tab.get(nouveauDepart) + s.getLongueur());	
						ArrayList<Intersection> liste = (ArrayList<Intersection>) tabIntersection.get(nouveauDepart).clone();
						ArrayList<String> listeNomRues = (ArrayList<String>) tabNomRues.get(nouveauDepart).clone();
						liste.add(s.getFin());
						listeNomRues.add(s.getNom());
						tabIntersection.put(s.getFin(), liste);
						tabNomRues.put(s.getFin(), listeNomRues);
					}
			}
			
			visitee.add(nouveauDepart);
			nonVisitee.remove(nouveauDepart);
			voisinArrivee.remove(nouveauDepart);
		}
		//Pair<Double, ArrayList<Intersection>> ret = new Pair<Double, ArrayList<Intersection>>(tab.get(arrivee),tabIntersection.get(arrivee));
		Itineraire itineraire = new Itineraire(tabIntersection.get(arrivee),tabNomRues.get(arrivee) ,tab.get(arrivee));
		
		return itineraire;
	}
	
	
	public ArrayList<Long> getIntersectionId() {
		return intersectionId;
	}
	public void setIntersectionId(ArrayList<Long> intersectionId) {
		this.intersectionId = intersectionId;
	}
	public ArrayList<Intersection> getIntersection() {
		return intersection;
	}
	public void setIntersection(ArrayList<Intersection> intersection) {
		this.intersection = intersection;
	}
	public ArrayList<Segment> getSegment() {
		return segment;
	}
	public void setSegment(ArrayList<Segment> segment) {
		this.segment = segment;
	}

	
	public HashMap<Long, Integer> getIntersectionIdRetourne() {
		return intersectionIdRetourne;
	}
	public void setIntersectionIdRetourne(HashMap<Long, Integer> intersectionIdRetourne) {
		this.intersectionIdRetourne = intersectionIdRetourne;
	}
	/** on construit un objet plan et toutes les structures de données qui facilitent son utilisation
	 * 
	 * @param intersectionId
	 * @param intersection
	 * @param segment
	 */
	
	public Plan(ArrayList<Long> intersectionId, ArrayList<Intersection> intersection, ArrayList<Segment> segment) {
		super();

		this.intersectionId = intersectionId;
		this.intersection = intersection;
		this.segment = segment;
		for(int i = 0; i < this.intersectionId.size(); i++) {
			this.intersectionIdRetourne.put(intersectionId.get(i), i);	
		}
		
		for(int i = 0; i < this.intersectionId.size(); i++) {
			ArrayList<Segment> vide = new ArrayList<Segment>();
			this.listeAdjacence.put(this.intersection.get(i), vide);
		}
		
		for(int j = 0 ; j < this.segment.size(); j ++)
		{
			ArrayList<Segment> listeSegmentsAssocies = this.listeAdjacence.get(this.segment.get(j).getOrigine());
			listeSegmentsAssocies.add(this.segment.get(j));
			this.listeAdjacence.put(this.segment.get(j).getOrigine(), listeSegmentsAssocies );
		}
		
		
		for(int i = 0; i < this.intersectionId.size(); i++) {
			ArrayList<Segment> videDeux = new ArrayList<Segment>();
			this.listeAdjacenceInverse.put(this.intersection.get(i), videDeux);
		}
		
		for(int j = 0 ; j < this.segment.size(); j ++)
		{
			ArrayList<Segment> listeSegmentsAssocies = this.listeAdjacenceInverse.get(this.segment.get(j).getFin());
			listeSegmentsAssocies.add(this.segment.get(j));
			this.listeAdjacenceInverse.put(this.segment.get(j).getFin(), listeSegmentsAssocies );
		}
	} 
	
	public Plan(ArrayList<Long> intersectionId, HashMap<Long, Integer> intersectionIdRetourne,
			ArrayList<Intersection> intersection, ArrayList<Segment> segment) {
		super();
		this.intersectionId = intersectionId;
		this.intersectionIdRetourne = intersectionIdRetourne;
		this.intersection = intersection;
		this.segment = segment;
	}
	public Plan() {
		super();
	}

	@Override
	public String toString() {
		return "Plan [intersectionId=" + intersectionId + ", intersection=" + intersection + " ]";
	}
	
	/**
	 * Cette fonction renvoie une intersection dont l'id correspond à celui passé en commentaire
	 * @param id
	 * @return
	 */
	
	public Intersection getIntersectionById(Long id){

		return this.intersection.get(this.intersectionIdRetourne.get(id));
	}
	
	/**
	 * Cette méthode renvoie la longitude maximale de tout les sommets du graphe.
	 * @return Double 
	 */
	public Double longitudeMax(){
		Double max = this.intersection.get(0).getLongitude();
		for(int i = 0; i < this.intersectionId.size(); i++) {
			if(max < this.intersection.get(i).getLongitude()) {
				max = this.intersection.get(i).getLongitude();
			}
		}
		return max;
	}
	/**
	 * Cette méthode renvoie la latitude maximale de tout les sommets du graphe.
	 * @return Double 
	 */
	public Double latitudeMax(){
		Double max = this.intersection.get(0).getLatitude();
		for(int i = 0; i < this.intersectionId.size(); i++) {
			if(max < this.intersection.get(i).getLatitude()) {
				max = this.intersection.get(i).getLatitude();
			}
		}
		return max;
	}
	/**
	 * Cette méthode renvoie la longitude minimale de tout les sommets du graphe.
	 * @return Double 
	 */
	
	public Double longitudeMin(){
		Double min = this.intersection.get(0).getLongitude();
		for(int i = 0; i < this.intersectionId.size(); i++) {
			if(min > this.intersection.get(i).getLongitude()) {
				min = this.intersection.get(i).getLongitude();
			}
		}
		return min;
	}
	/**
	 * Cette méthode renvoie la latitude minimale de tout les sommets du graphe.
	 * @return Double 
	 */
	public Double latitudeMin(){
		Double min = this.intersection.get(0).getLatitude();
		for(int i = 0; i < this.intersectionId.size(); i++) {
			if(min > this.intersection.get(i).getLatitude()) {
				min = this.intersection.get(i).getLatitude();
			}
		}
		return min;
	}
	

};




